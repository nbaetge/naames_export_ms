---
title: "Export MS Supplemental Climatology Analysis"
author: "Nicholas Baetge"
date: "1/22/2020"
output: github_document
---
# Intro 

These analyses were conducted in order to respond to the suggestion to validate our results with publicly available datasets.

1. Here, we have used [GLODAPv2_2019](https://www.nodc.noaa.gov/archive/arc0133/0186803/2.2/data/0-data/) and [WOA18](https://www.nodc.noaa.gov/OC5/woa18/woa18data.html) constiuent and climatological data to verify the mixed nitrate and silicate profiles approximated in the manuscript. We also used the freely available data to estimate NCP from both nitrate and TCO~2~ drawdown and compared those estimates to the ones in the manuscript. 

2. We also analyzed UCSD's ARGO monthly maximum MLD climatology data product to explore interannual variability in maximum mixed layer depths.

```{r include=FALSE}
library(tidyverse)
library(oce)
library(ncdf4)
library(lattice)
library(zoo)
library(scales)
library(RColorBrewer)
library(knitr)
#stat tests
library(lmtest)
library(lmodel2)
#rmarkdown tables
library(stargazer)
library(pander)
```

```{r include=FALSE}
custom_theme <- function() {
  theme_test(base_size=20) %+replace%
    theme(legend.position="top",
          legend.title = element_blank(),
          legend.spacing.x = unit(0.5,"cm"),
          legend.background = element_rect(fill = "transparent",colour = NA),
          legend.key = element_rect(fill = "transparent",colour = NA),
          panel.background = element_rect(fill = "transparent",colour = NA),
          plot.background = element_rect(fill = "transparent",colour = NA)) 
}

custom.colors <- c("AT39" = "#377EB8", "AT34" = "#4DAF4A", "AT38" = "#E41A1C", "AT32" = "#FF7F00", "Temperate" = "#A6CEE3", "Subpolar" = "#377EB8", "Subtropical" = "#FB9A99", "GS/Sargasso" = "#E41A1C", "Early Spring" = "#377EB8", "Late Spring" = "#4DAF4A","Early Autumn" = "#E41A1C", "Summer" = "#E41A1C", "Late Autumn" = "#FF7F00", "Gv2_2019" = "#377EB8", "WOA18_MN" = "#4DAF4A", "WOA18_AN" = "#E41A1C", "ARGO" = "#377EB8", "Cruise" = "#AF7AC5", "Climatology" = "#FDB927")

levels = c("GS/Sargasso", "Subtropical", "Temperate", "Subpolar",  "AT39-6", "AT34", "AT38", "AT32","South", "North", "Early Spring", "Late Spring","Early Autumn",  "Summer", "Late Autumn", "Gv2_2019", "WOA18_MN", "WOA18_AN","Nov", "Nov sd", "Dec", "Dec sd", "Jan", "Jan sd", "Feb", "Feb sd", "Mar", "Mar sd", "Apr", "Apr sd",  "Cruise", "ARGO")

```

# Manuscript Data

```{r}
export_summary <- read_rds("~/Google Drive File Stream/Shared drives/NAAMES_Carlson/DATA/FINAL/MANUSCRIPT_DATA/Export_MS/Output/processed_export.rds")

mlds <-  read_rds("~/Google Drive File Stream/Shared drives/NAAMES_Carlson/DATA/FINAL/MANUSCRIPT_DATA/Export_MS/Output/processed_bf.2.2020.rds") %>% 
  select(Season, Station, CampCN, degree_bin, Latitude, Max_MLD, Z_MLD) %>%
  group_by(Season, Station) %>% 
  mutate(mean_mld = mean(Z_MLD),
         sd_mld = sd(Z_MLD),
         ave_lat = mean(Latitude)) %>% 
  ungroup() %>% 
  select(Season, Station, degree_bin, ave_lat, Max_MLD, mean_mld, sd_mld) %>% 
  distinct() 

naames_mld <- mlds %>% 
  select(-Max_MLD, -ave_lat) %>% 
  distinct()

argo_mld <- mlds %>% 
  select(degree_bin, Max_MLD) %>% 
  distinct() 
  

```

# GLODAPv2_2019

This dataset is described in:  
*Olsen, A., R. M. Key, S. van Heuven, S. K. Lauvset, A. Velo, X. Lin, C. Schirnick, A. Kozyr, T. Tanhua, M. Hoppema, S. Jutterström, R. Steinfeldt, E. Jeansson, M. Ishii, F. F. Pérez and T. Suzuki. The Global Ocean Data Analysis Project version 2 (GLODAPv2) – an internally consistent data product for the world ocean, Earth Syst. Sci. Data, 8, 297–323, 2016, doi:10.5194/essd-8-297-2016.*

Here is the [readme](https://www.nodc.noaa.gov/archive/arc0133/0186803/2.2/data/0-data/README.txt) 

### Data wrangling
```{r message = FALSE}
glodap <- read_csv("https://www.nodc.noaa.gov/archive/arc0133/0186803/2.2/data/0-data/GLODAPv2.2019_Atlantic_Ocean.csv")

```

We are only including variables we're interested in as well as data that are co-located in the NAAMES study region.

```{r warning = FALSE}
glodap.region <- glodap %>% 
  select(cruise:longitude, bottle:temperature, salinity:salinityqc, nitrate:nitrateqc, silicate:silicateqc, tco2:tco2qc) %>% 
  filter(between(longitude, -47, -38),
         between(latitude, 39, 57)) %>% 
  mutate(bin = round(latitude)) %>% 
  mutate_all(funs(gsub(-9999, NA, .))) 

```

```{r}
str(glodap.region)
```

### Winter profiles

We want to plot the winter profiles and estimate the nitrate and silicate concentrations within the mixed layers of the profiles. We'll need to wrangle the data first:

- restrict data to winter months (Jan - March)
- estimate MLDs using the temperature criterion of de Boyer Montegut, 2004: *"...threshold value of temperature or density from a near-surface value at 10 m depth ($∆T = 0.2°C$ or $∆\sigma = 0.03$ $kg$ $m^{-3}$)."*

```{r}
glodap.winter <- glodap.region %>% 
  filter(month %in% c(1,2,3)) %>% 
  drop_na(nitrate) %>% 
  #the dataframe is composed of character data, so we will coerce  all the data into numerics
  data.matrix() %>% 
  as_tibble() %>% 
  group_by(cruise, station) %>% 
  arrange(bin, cruise, station, bottle) %>% 
  mutate(bin_plot = paste(bin, "˚N", sep = ""),
         #convert nutrients to µmol/L and TCO2 to mol/l
         nitrate = nitrate * 1.025,
         silicate = silicate * 1.025,
         tco2 = (tco2 * 1.025)/1000,
         #identify near surface temperature
         surf_t = ifelse(depth == 10, temperature, NA),
         #calculate the temperature threshold
         mld_t = surf_t - 0.2) %>% 
  fill(surf_t:mld_t, .direction = "up") %>% 
  ungroup() %>% 
  select(cruise:longitude, bin, bin_plot, everything())
```

```{r}
unique(glodap.winter$cruise)
```

```{r}
unique(glodap.winter$station)
```
**The restricted dataset only includes data from one cruise and two stations i.e. there are only two winter nutrient profiles in the NAAMES region this dataset.**

To be able to estimate MLDs, we'll need to interpolate the depth at which the temperature threshold is reached. We'll then need to interpolate the relevant data for that depth.

```{r}
#split the dataframe into a list, by station
glodap.winter.list <-  split(glodap.winter, glodap.winter$station)
```

```{r}
#create a function that adds an empty row to each station and also inputs the temperature threshold value int to the temperature column
addz.func <- function(a){
  #add an empty row to each list element
  a[nrow(a) + 1,] <- NA
  #add the mld_t value to the empty field in the temperature column
  a$temperature[is.na(a$temperature)] <- max(a$mld_t, na.rm = T)
  #fill the metadata for the empty row
  b <- a %>% 
    fill(., cruise:bin_plot, .direction = c("downup")) 
  }
```

```{r}
#apply function to list
added.mld_t.list <- lapply(glodap.winter.list, addz.func)
```

```{r}
#save the list as a data frame 
added.mld_t.df <- plyr::ldply(added.mld_t.list, data.frame) %>% 
  group_by(station) %>% 
  distinct(., temperature, .keep_all = T) %>% 
  select(-.id) %>% 
  ungroup() %>% 
  arrange(station,  temperature)
```

```{r}
#again, split the dataframe into a list
to_interpolate.list <- split(added.mld_t.df, added.mld_t.df$station)
```

```{r}
#create a function that will linearly interpolate each variable according to the depth intervals of the casts 
interpolate.func <- function(a) {
b <- a %>% 
  select(depth:ncol(.)) %>% 
  zoo(., order.by = .$temperature) 
interp_depth <- round(as.numeric(na.approx(b$depth, na.rm = F)))
c <- a %>% 
  mutate(depth = interp_depth)
d <- c %>%
  select(depth:ncol(.)) %>% 
  zoo(., order.by = .$depth)
interp_nitrate <- as.numeric(na.approx(d$nitrate, na.rm = F))
interp_silicate <- as.numeric(na.approx(d$silicate, na.rm = F))
interp_tco2 <- as.numeric(na.approx(d$tco2, na.rm = F))
depth <- d$depth
temperature <- d$temperature
e <- data.frame(depth, temperature, interp_nitrate, interp_silicate, interp_tco2)

}

```

```{r}
#apply function to list 
interpolations.list <- lapply(to_interpolate.list, interpolate.func)
```

```{r}
#save the list as a data frame 
interpolations.df <- plyr::ldply(interpolations.list, data.frame) %>% 
  rename(., station = .id) 
```

```{r message = F}
#combine the interpolated and non-interpolated data frames 
interpolations.df$station <- as.numeric(interpolations.df$station)
interpolated.df <- right_join(added.mld_t.df, interpolations.df) %>%
  group_by(station) %>% 
  arrange(station, depth) %>% 
  fill(., cruise, cast:bin_plot, mld_t, .direction = "downup") %>% 
  select(-surf_t)
```

```{r}
#identify the mld and calculate the mixed conditions
glodap.winter.interp <- interpolated.df %>%
  group_by(station) %>% 
  mutate(mld = ifelse(temperature == mld_t, depth, NA)) %>% 
  fill(mld, .direction = "downup") 
```

```{r fig.height = 10, fig.width = 10, fig.align = "center"}
#plot the profiles with an indication of the MLD
n.prof <-  glodap.winter.interp %>% 
  filter(depth <= 1500) %>% 
  ggplot(aes(x = depth, group = bin_plot, y = interp_nitrate)) +
  geom_segment(aes( x = mld, xend = mld, y = 0, yend = 25, group = bin), colour="black", linetype = 2, size = 1.5 ) +
  geom_line(size = 0.7) +
  geom_point(size = 6, shape = 21, color = "black", stroke = 1, alpha = 0.7) + 
  labs(x = expression(paste("")), y = expression(paste("NO"[3],", µmol N L"^"-1")), colour = "") +
  scale_x_reverse(breaks = pretty_breaks(), expand = c(0,0)) +
  coord_flip() +
  scale_y_continuous(expand = c(0,0), sec.axis = dup_axis(), limits = c(0,25)) +
  guides(colour = F) +
  guides(fill = F) +
  custom_theme() +
  facet_wrap(~bin_plot) +
  theme(panel.spacing.x = unit(2, "cm"))

n.prof
```

```{r fig.height = 10, fig.width = 10, fig.align = "center", echo = FALSE}
#plot the profiles with an indication of the MLD
si.prof <-  glodap.winter.interp %>% 
  filter(depth <= 1500) %>% 
  ggplot(aes(x = depth, group = bin_plot, y = interp_silicate)) +
  geom_segment(aes( x = mld, xend = mld, y = 0, yend = 25, group = bin), colour="black", linetype = 2, size = 1.5 ) +
  geom_line(size = 0.7) +
  geom_point(size = 6, shape = 21, color = "black", stroke = 1, alpha = 0.7) + 
  labs(x = expression(paste("")), y = expression(paste("SiO"[4],", µmol Si L"^"-1")), colour = "") +
  scale_x_reverse(breaks = pretty_breaks(), expand = c(0,0)) +
  coord_flip() +
  scale_y_continuous(expand = c(0,0), sec.axis = dup_axis(), limits = c(0,25)) +
  guides(colour = F) +
  guides(fill = F) +
  custom_theme() +
  facet_wrap(~bin_plot) +
  theme(panel.spacing.x = unit(2, "cm"))

si.prof
```

**Only one of these profiles reflect a possible winter mixed condition**

```{r}
glodap.winter.cond <- glodap.winter.interp %>% 
  filter(station == 181,
         depth <= mld) %>% 
  mutate(winter_n = mean(interp_nitrate),
         winter_si = mean(interp_silicate),
         winter_tco2 = mean(interp_tco2)) %>% 
  ungroup() %>% 
  select(bin, mld, winter_n:winter_tco2) %>% 
  distinct()
```

```{r echo = FALSE, results = 'asis'}
kable(glodap.winter.cond, caption = "Gv2_2019 Winter Conditions")
```


## Caclulate NCP from TCO~2~ profiles

We'll calculate seasonal NCP, from winter to spring and winter to summer, depth-integrated to 100 m. These are the most comparable estimates to those presented in the manuscript.

Because there was only one latitudinal bin in the NAAMES study region that had a profile reflecting deep mixing, we will restrict the data to that bin. 

Below shows how seasonal NCP was calculated from the winter to the spring. The same workflow was done for the period of winter to summer, but that is not shown. 

### Spring NCP

```{r}
glodap.spring <- glodap.region %>% 
  filter(month %in% c(4,5,6)) %>% 
  drop_na(tco2) %>% 
  data.matrix() %>% 
  as_tibble() %>% 
  filter(bin == 42) %>% 
  group_by(station) %>% 
  arrange(station, bottle) %>% 
  mutate(min_depth = min(depth)) %>% 
  #filter out casts in which the minimum depth sampled is >=20 m 
  filter(!min_depth >= 20) %>% 
  filter(depth <= 100) %>% 
  ungroup() %>% 
  #restict data to stations with >= 3 observations
  filter(station %in% c(64, 78)) %>% 
  ungroup()
  
```

```{r}
#create a function to add an empty row0 and 100 m  
add_0_100.func <- function(a){
  a[nrow(a) + 1,] <- NA
  a$depth[is.na(a$depth)] <- 0
  
  b <- a %>% 
    fill(., cruise:longitude, .direction = "downup") %>% 
    arrange(station, depth)
  
  b[nrow(b) + 1,] <- NA
  b$depth[is.na(b$depth)] <- 100
  
  c <- b %>% 
    fill(., cruise:longitude, .direction = "downup") %>% 
    arrange(station, depth)
  
}
```

```{r}
#split df into list
add.spring.list <- split(glodap.spring, glodap.spring$station)
#apply function to list
added.spring.list <- lapply(add.spring.list, add_0_100.func)
```

```{r}
#save the list as a data frame 
added.spring.df <- plyr::ldply(added.spring.list, data.frame) %>% 
  group_by(station) %>% 
  distinct(., depth, .keep_all = T) %>% 
  select(-.id) %>% 
  #the nearest values to 0 m and 100 m are 9-11 and 98-99 m, respectively. so, we can fill the TCO2 values for 0 and 100 m. 
  fill(tco2, .direction = "downup") %>% 
  ungroup() 
```

```{r, message = FALSE}
#calculate spring ncp
ncp_spring <- added.spring.df %>% 
  group_by(station) %>% 
  mutate(tco2 = (tco2 * 1.025)/1000,
         tco2_100 = integrateTrapezoid(depth, tco2, type = "A")) %>% 
  ungroup() %>% 
  group_by(bin) %>%
  mutate(tco2_100_spring = mean(tco2_100)) %>% 
  select(bin,tco2_100_spring) %>%  
  ungroup() %>% 
  distinct() %>% 
  left_join(glodap.winter.interp, .) %>% 
  group_by(station) %>% 
  mutate(tco2_winter = ifelse(depth <= mld, mean(interp_tco2, na.rm = T), NA),
         tco2_100_winter = ifelse(!is.na(tco2_winter), tco2_winter * 100, NA), 
         ncp_spring = tco2_100_winter - tco2_100_spring) %>% 
  select(cruise, station, year, bin, mld, tco2_winter, tco2_100_winter, tco2_100_spring, ncp_spring) %>% 
  distinct() %>% 
  drop_na(ncp_spring) %>% 
  mutate_at(vars(tco2_winter:ncp_spring), round, 1) %>% 
  ungroup()
```

```{r echo = FALSE, results = 'asis'}
kable(ncp_spring, caption = "Gv2_2019 Spring NCP")
```


```{r include = FALSE}
glodap.summer <- glodap.region %>% 
  filter(month %in% c(7,8,9)) %>% 
  drop_na(tco2) %>% 
  data.matrix() %>% 
  as_tibble() %>% 
  filter(bin == 42) %>% 
  group_by(station) %>% 
  arrange(station, bottle) %>% 
  mutate(min_depth = min(depth)) %>% 
  filter(depth <= 100) %>% 
  ungroup() %>% 
  #restict data to stations with >= 3 observations
  filter(station %in% c(27, 465, 468)) 
  
```


```{r include = FALSE}
#split df into list
add.summer.list <- split(glodap.summer, glodap.summer$station)
#apply function to list
added.summer.list <- lapply(add.summer.list, add_0_100.func)
```

```{r include = FALSE}
#save the list as a data frame 
added.summer.df <- plyr::ldply(added.summer.list, data.frame) %>% 
  group_by(station) %>% 
  distinct(., depth, .keep_all = T) %>% 
  select(-.id) %>% 
  #the nearest values to 0 m and 100 m are 9-11 and 98-99 m, respectively. so, we can fill the TCO2 values for 0 and 100 m. 
  fill(tco2, .direction = "downup") %>% 
  ungroup() 
```

```{r include = FALSE}
#calculate summer ncp
ncp_summer <- added.summer.df %>% 
  group_by(station) %>% 
  mutate(tco2 = (tco2 * 1.025)/1000,
         tco2_100 = integrateTrapezoid(depth, tco2, type = "A")) %>% 
  ungroup() %>% 
  group_by(bin) %>%
  mutate(tco2_100_summer = mean(tco2_100)) %>% 
  select(bin,tco2_100_summer) %>%  
  ungroup() %>% 
  distinct() %>% 
  left_join(glodap.winter.interp, .) %>% 
  group_by(station) %>% 
  mutate(tco2_winter = ifelse(depth <= mld, mean(interp_tco2, na.rm = T), NA),
         tco2_100_winter = ifelse(!is.na(tco2_winter), tco2_winter * 100, NA), 
         ncp_summer = tco2_100_winter - tco2_100_summer) %>% 
  select(cruise, station, year, bin, mld, tco2_winter, tco2_100_winter, tco2_100_summer, ncp_summer) %>% 
  distinct() %>% 
  drop_na(ncp_summer) %>% 
  mutate_at(vars(tco2_winter:ncp_summer), round, 1) %>% 
  ungroup()
```

```{r echo = FALSE, results = 'asis'}
kable(ncp_summer, caption = "Gv2_2019 Summer NCP")
```



# WOA18 

The [WOA18](https://www.nodc.noaa.gov/OC5/woa18/woa18data.html) objective analyses and statistics data for temperature and nitrate were downloaded. 

The statistical mean is the average of all unflagged interpolated values at each standard depth level for each variable in each 1° square which contains at least one measurement for the given oceanographic variable. 

Objectively analyzed climatologies are the objectively interpolated mean fields for oceanographic variables at standard depth levels for the World Ocean.

We will first explore the profiles in the statistical mean data and if possible, calculate NCP from the nitrate data. We will then do the same for the climatolgical data.

### Statistical mean

#### Data wrangling

As for the Gv2_2019 dataset, we want to interrogate the winter profiles falling within the NAAMES region and estimate the nitrate and silicate concentrations within the mixed layers of the profiles. We'll need to wrangle the data first:

- restrict data to winter months (Jan - March)
- estimate MLDs using the temperature criterion of de Boyer Montegut, 2004.

##### Mixed Layer Depths

```{r message = FALSE, warning = FALSE}
woa.winter.t <- read_csv("~/Google Drive File Stream/Shared drives/NAAMES_Carlson/DATA/FINAL/MANUSCRIPT_DATA/Export_MS/Input/WOA18_statistical_mean/woa18_decav_t13mn01.csv", skip = 1) %>% 
  rename(lat = LATITUDE,
         lon = LONGITUDE) %>% 
  gather(., key = "depth", value = "t", -lat, -lon) %>% 
  mutate(depth = as.numeric(depth)) %>% 
  arrange(lat, lon, depth) %>% 
  filter(between(lon, -47, -38),
         between(lat, 39,57)) %>% 
  drop_na() %>% 
  mutate(bin = ceiling(lat)) %>% 
  group_by(lat, lon) %>% 
  mutate(surf_t = ifelse(depth == 10, t, NA),
         #calculate the temperature threshold
         mld_t = surf_t - 0.2) %>% 
  fill(surf_t:mld_t, .direction = "downup") %>% 
  ungroup() %>% 
  mutate(coord = paste(lat, lon, sep=",")) %>% 
  select(lat, lon, coord, bin, surf_t, mld_t, everything())
```

To be able to estimate MLDs, we'll need to interpolate the depth at which the temperature threshold is reached. We'll then need to interpolate the relevant data for that depth late.

```{r}
#split the dataframe into a list, by coordinates
woa.winter.t.list <-  split(woa.winter.t, woa.winter.t$coord)
```


```{r}
#create a function that adds an empty row to each station and also inputs the temperature threshold value int to the temperature column
woa_addz.func <- function(a){
  #add an empty row to each list element
  a[nrow(a) + 1,] <- NA
  b <- a %>% 
    fill(., lat:mld_t, .direction = c("downup")) 
  }
```

```{r}
#apply function to list
added.mld.woa.winter.list <- lapply(woa.winter.t.list, woa_addz.func)
```

```{r}
#save the list as a data frame 
added.mld.woa.winter.df <- plyr::ldply(added.mld.woa.winter.list, data.frame) %>% 
  group_by(coord) %>% 
  distinct(., t, .keep_all = T) %>% 
  select(-.id) %>% 
  mutate(t = ifelse(is.na(t), mld_t, t)) %>% 
  ungroup() %>% 
  arrange(coord, t)
```

```{r}
#again, split the dataframe into a list
to_interpolate.woa.winter.list <- split(added.mld.woa.winter.df, added.mld.woa.winter.df$coord)
```

```{r warning = FALSE}
#create a function that will linearly interpolate depth according to the temperature profiles
woa_interpolate_mld.func <- function(a) {
b <- a %>% 
  select(depth:ncol(.)) %>% 
  zoo(., order.by = .$t) 
interp_depth <- round(as.numeric(na.approx(b$depth, na.rm = F)))
c <- a %>% 
  mutate(depth = interp_depth)
}

```

```{r message = FALSE, warning = FALSE}
#apply function to list 
woa_interpolated_mld.list <- lapply(to_interpolate.woa.winter.list, woa_interpolate_mld.func)
```

```{r}
#save the list as a data frame and identify the mld
woa_mld.df <- plyr::ldply(woa_interpolated_mld.list, data.frame) %>% 
  select(-.id) %>% 
  group_by(coord) %>% 
  mutate(mld = ifelse(t == mld_t, depth, NA)) %>% 
  ungroup() %>% 
  select(lat, lon, bin, mld) %>% 
  distinct() %>% 
  drop_na(mld)
```

##### Nitrate

```{r message = FALSE}
woa.winter.n <- read_csv("~/Google Drive File Stream/Shared drives/NAAMES_Carlson/DATA/FINAL/MANUSCRIPT_DATA/Export_MS/Input/WOA18_statistical_mean/woa18_all_n13mn01.csv", skip = 1) %>% 
  rename(lat = LATITUDE,
         lon = LONGITUDE) %>% 
  gather(., key = "depth", value = "winter_nitrate", -lat, -lon) %>% 
  mutate(depth = as.numeric(depth)) %>% 
  arrange(lat, lon, depth) %>% 
  filter(between(lon, -47, -38),
         between(lat, 39,57)) %>% 
  drop_na() %>% 
  mutate(bin= ceiling(lat),
         winter_nitrate = winter_nitrate * 1.025) %>% 
  group_by(bin) %>% 
  mutate(woa_n = mean(winter_nitrate),
         woa_n_sd = sd(winter_nitrate)) %>% 
  mutate_at(vars(woa_n, woa_n_sd), round, 1) %>% 
  select(bin, depth, woa_n, woa_n_sd) %>% 
  add_tally() %>% 
  distinct() %>% 
  ungroup()
```

```{r echo = FALSE, results = 'asis'}
kable(woa.winter.n, caption = "WOA18 Winter Nitrate Observations")
```

**Because there are only 4 winter nitrate observations, all of which are at 0 m, we cannot calculate depth-integrated NCP values that would be comparable to those in the manuscript**

##### Silicate

Unlike nitrate, there are several silicate profiles co-located in the NAAMES study region, so we can caluclate mixed layer winter silicate conditions for each of the 1˚ latitudinal bins. 

```{r message = F}
woa.winter.si <- read_csv("~/Google Drive File Stream/Shared drives/NAAMES_Carlson/DATA/FINAL/MANUSCRIPT_DATA/Export_MS/Input/WOA18_statistical_mean/woa18_all_i13mn01.csv", skip = 1) %>% 
  rename(lat = LATITUDE,
         lon = LONGITUDE) %>% 
  gather(., key = "depth", value = "winter_silicate", -lat, -lon) %>% 
  mutate(depth = as.numeric(depth)) %>% 
  arrange(lat, lon, depth) %>% 
  filter(between(lon, -47, -38),
         between(lat, 39,57)) %>% 
  drop_na() %>% 
  mutate(bin = ceiling(lat),
         winter_silicate = winter_silicate * 1.025) %>% 
  mutate_at(vars(winter_silicate), round, 1) %>% 
  left_join(., woa_mld.df ) %>% 
  mutate(coord = paste(lat, lon, sep = ",")) %>% 
  select(lat, lon, coord, bin, mld, depth, winter_silicate) %>% 
  #there are a few places where there is only 1 measurement. these will be omitted from analysis
  filter(!coord %in% c("49.5,-43.5", "50.5,-41.5", "50.5,-42.5", "51.5,-41.5", "53.5,-38.5"))
```

```{r}
#split the dataframe into a list, by coordinates
woa.winter.si.list <-  split(woa.winter.si, woa.winter.si$coord)
```


```{r}
#create a function that adds an empty row to each station and also inputs the mld the depth column
woa_add_mld.func <- function(a){
  #add an empty row to each list element
  a[nrow(a) + 1,] <- NA
  #add the mld value to the empty field in the depth column
  a$depth[is.na(a$depth)] <- max(a$mld, na.rm = T)
  #fill the metadata for the empty row
  b <- a %>% 
    fill(., lat:mld, .direction = c("downup")) 
  }
```

```{r, message = FALSE, warning = FALSE}
#apply function to list
added.mld.woa.winter.si.list <- lapply(woa.winter.si.list, woa_add_mld.func)
```

```{r}
#save the list as a data frame 
added.mld.woa.winter.si.df <- plyr::ldply(added.mld.woa.winter.si.list, data.frame) %>% 
  group_by(coord) %>% 
  distinct(., depth, .keep_all = T) %>% 
  select(-.id) %>% 
  ungroup() %>% 
  arrange(coord, depth)

```

```{r}
#again, split the dataframe into a list
to_interpolate.woa.winter.si.list <- split(added.mld.woa.winter.si.df, added.mld.woa.winter.si.df$coord)
```

```{r}
#create a function that will linearly interpolate silicate according to the depth intervals 
woa_interpolate_si.func <- function(a) {
b <- a %>% 
  select(depth:ncol(.)) %>% 
  zoo(., order.by = .$depth) 
interp_si <- round(as.numeric(na.approx(b$winter_silicate, na.rm = F)),1)
c <- a %>% 
  mutate(winter_silicate = interp_si)
}

```

```{r}
#apply function to list 
woa_interpolated_si.list <- lapply(to_interpolate.woa.winter.si.list, woa_interpolate_si.func)
```

```{r}
#save the list as a data frame and calculate the mixed layer silicate concentration
woa_si_interp.df <- plyr::ldply(woa_interpolated_si.list, data.frame) %>% 
  select(-.id) %>% 
  group_by(coord) %>% 
  filter(depth <= mld) %>% 
  mutate(winter_si = round(mean(winter_silicate, na.rm = T),1)) %>%
  ungroup() %>% 
  select(lat, lon, bin, mld, winter_si) %>% 
  distinct() %>%
  group_by(bin) %>%
  add_tally() %>%
  filter(mld == max(mld))
```

```{r echo = FALSE, results = 'asis'}
kable(woa_si_interp.df, caption = "WOA18 Winter Silicate Conditions. MLDs represent the maximum calculated MLD for the profiles within a coordinate (profiles that have silicate measurments). n refers to the total number of profiles for  each coordinate.")
```

**Note the depth of the mixed layers here.

### Climatology

As we proceed with the analysis, keep in mind the climatology dataset is influenced by the number of statistical mean observations. The number of observations that exist in in this dataset for the NAAMES region is 4 and those observations are not depth-resolved. 

#### Data wrangling

As above, we ascertain winter profiles falling within the NAAMES region and estimate the nitrate concentrations within the mixed layers of the profiles. We'll need to wrangle as done previously to do so.

After the winter condition is defined, we can estimate nitrate inventories within the top 100 m during the spring (Apr-Jun) and summer (Jul-Sep). The delta between the nitrate inventory within the top 100 m during the winter and that of the subsequent season can provide an estimate of NCP, following Redfield conversion of N to C. 

##### Mixed Layer Depths

We'll use the mixed layer depths that were calculated using the statistical mean temperature data

##### Nitrate

```{r message = F}
woa.winter.n.clim <- read_csv("~/Google Drive File Stream/Shared drives/NAAMES_Carlson/DATA/FINAL/MANUSCRIPT_DATA/Export_MS/Input/WOA18_obj_an_mean/woa18_all_n13an01.csv", skip = 1) %>% 
  rename(lat = LATITUDE,
         lon = LONGITUDE) %>% 
  gather(., key = "depth", value = "winter_nitrate", -lat, -lon) %>% 
  mutate(depth = as.numeric(depth)) %>% 
  arrange(lat, lon, depth) %>% 
  filter(between(lon, -47, -38),
         between(lat, 39,57)) %>% 
  drop_na() %>% 
  mutate(bin = ceiling(lat),
         winter_nitrate = round(winter_nitrate * 1.025,1)) %>% 
  left_join(., woa_mld.df %>% 
              group_by(bin) %>%  
              filter(mld == max(mld, na.rm = T)) %>% 
              select(bin, mld) %>% 
              distinct()) %>% 
  mutate(coord = paste(lat, lon, sep = ",")) %>% 
  select(lat, lon, coord, bin, mld, depth, winter_nitrate)
```

```{r}
#split the dataframe into a list, by coordinates
woa.winter.n.clim.list <-  split(woa.winter.n.clim, woa.winter.n.clim$coord)
```


```{r, message = FALSE, warning = FALSE}
#apply function to list
added.mld.woa.winter.n.clim.list <- lapply(woa.winter.n.clim.list, woa_add_mld.func)
```

```{r}
#save the list as a data frame 
added.mld.woa.winter.n.clim.df <- plyr::ldply(added.mld.woa.winter.n.clim.list, data.frame) %>% 
  group_by(coord) %>% 
  distinct(., depth, .keep_all = T) %>% 
  select(-.id) %>% 
  ungroup() %>% 
  arrange(coord, depth)

```

```{r}
#again, split the dataframe into a list
to_interpolate.woa.winter.n.clim.list <- split(added.mld.woa.winter.n.clim.df, added.mld.woa.winter.n.clim.df$coord)
```

```{r}
#create a function that will linearly interpolate nitrate according to the depth intervals 
woa_interpolate_n.func <- function(a) {
b <- a %>% 
  select(depth:ncol(.)) %>% 
  zoo(., order.by = .$depth) 
interp_n <- round(as.numeric(na.approx(b$winter_nitrate, na.rm = F)),1)
c <- a %>% 
  mutate(winter_nitrate = interp_n)
}

```

```{r}
#apply function to list 
woa.clim_interpolated_n.list <- lapply(to_interpolate.woa.winter.n.clim.list, woa_interpolate_n.func)
```

```{r}
#save the list as a data frame and calculate the mixed layer nitrate concentration for each latitudinal bin
woa.clim_n_interp.df <- plyr::ldply(woa.clim_interpolated_n.list, data.frame) %>% 
  select(-.id) %>% 
  group_by(coord) %>% 
  filter(depth <= mld) %>% 
  mutate(coord_winter_n = round(mean(winter_nitrate, na.rm = T),1)) %>%
  ungroup() %>% 
  select(lat,lon, bin, mld, coord_winter_n) %>% 
  distinct() %>%
  group_by(bin) %>%
  mutate(bin_winter_n = round(mean(coord_winter_n, na.rm = T),1),
         bin_winter_n_sd = round(sd(coord_winter_n, na.rm = T),1)) %>%
  add_tally() %>%
  select( bin, mld, bin_winter_n, bin_winter_n_sd, n) %>% 
  ungroup() %>% 
  distinct() %>% 
  mutate(bin_winter_n_100 = (bin_winter_n * 100)/1000)
```

```{r echo = FALSE, results = 'asis'}
kable(woa.clim_n_interp.df, caption = "WOA18 Climatology Winter Nitrate Conditions. MLDs represent the maximum calculated MLD for the profiles within latitudinal bin. n refers to the total number of profiles for  each latitudinal bin (multiple because of the range in longitude). bin_winter_n_100 refers to nitrate depth integrated to 100 m in mol N m^-2")
```

##### NCP

Since we are calculating depth-integrated NCP over the top 100 m, we need to calculate the integrated nitrate stock over the top 100 m for the spring and summer seasons. The difference between those stocks and that of the winter condition, we can estimate nitrate drawdown and convert to NCP using the Redfield ratio. 

Below demonstrates the calculation for Spring NCP. The same calculations were done for the Summer, but those are not shown. 

```{r message = FALSE}
woa.clim.spring <- read_csv("~/Google Drive File Stream/Shared drives/NAAMES_Carlson/DATA/FINAL/MANUSCRIPT_DATA/Export_MS/Input/WOA18_obj_an_mean/woa18_all_n14an01.csv", skip = 1) %>% 
  rename(lat = LATITUDE,
         lon = LONGITUDE) %>% 
  gather(., key = "depth", value = "spring_n", -lat, -lon) %>% 
  mutate(depth = as.numeric(depth)) %>% 
  arrange(lat, lon, depth) %>% 
  filter(between(lon, -47, -38),
         between(lat, 39,57)) %>% 
  drop_na() %>%
  mutate(bin = ceiling(lat),
         spring_n = round(spring_n * 1.025),1) %>% 
  group_by(lat, lon) %>% 
  filter(depth <= 100) %>% 
  mutate(spring_n_100 = integrateTrapezoid(depth, spring_n,type="A")) %>% 
  ungroup() %>% 
  group_by(bin) %>%
  mutate(bin_spring_n_100 = round((mean(spring_n_100))/1000,2)) %>% 
  select(bin, bin_spring_n_100) %>%  
  ungroup() %>% 
  distinct() %>% 
  left_join(woa.clim_n_interp.df %>%  select(bin, bin_winter_n_100), .) %>% 
  mutate(delta_n_spring = bin_winter_n_100 - bin_spring_n_100,
        ncp_spring =  round(delta_n_spring * 6.6,2))
```

```{r echo = FALSE, results = 'asis'}
kable(woa.clim.spring, caption = "WOA18 Climatology Spring NCP in mol C m^-2")
```

```{r echo = FALSE, message = FALSE}
woa.clim.summer <- read_csv("~/Google Drive File Stream/Shared drives/NAAMES_Carlson/DATA/FINAL/MANUSCRIPT_DATA/Export_MS/Input/WOA18_obj_an_mean/woa18_all_n15an01.csv", skip = 1) %>% 
  rename(lat = LATITUDE,
         lon = LONGITUDE) %>% 
  gather(., key = "depth", value = "summer_n", -lat, -lon) %>% 
  mutate(depth = as.numeric(depth)) %>% 
  arrange(lat, lon, depth) %>% 
  filter(between(lon, -47, -38),
         between(lat, 39,57)) %>% 
  drop_na() %>%
  mutate(bin = ceiling(lat),
         summer_n = round(summer_n * 1.025),1) %>% 
  group_by(lat, lon) %>% 
  filter(depth <= 100) %>% 
  mutate(summer_n_100 = integrateTrapezoid(depth, summer_n,type="A")) %>% 
  ungroup() %>% 
  group_by(bin) %>%
  mutate(bin_summer_n_100 = round((mean(summer_n_100))/1000,2)) %>% 
  select(bin, bin_summer_n_100) %>%  
  ungroup() %>% 
  distinct() %>% 
  left_join(woa.clim_n_interp.df %>%  select(bin, bin_winter_n_100), .) %>% 
  mutate(delta_n_summer = bin_winter_n_100 - bin_summer_n_100,
         ncp_summer = round(delta_n_summer * 6.6,2))
```

```{r echo = FALSE, results = 'asis'}
kable(woa.clim.summer, caption = "WOA18 Climatology Summer NCP in mol C m^-2")
```

##### Silicate

As for nitrate, we need to estimate the silicate concentrations within the mixed layers of the profiles. We'll need to wrangle as done previously to do so.

```{r message = F}
woa.winter.si.clim <- read_csv("~/Google Drive File Stream/Shared drives/NAAMES_Carlson/DATA/FINAL/MANUSCRIPT_DATA/Export_MS/Input/WOA18_obj_an_mean/woa18_all_i13an01.csv", skip = 1) %>% 
  rename(lat = LATITUDE,
         lon = LONGITUDE) %>% 
  gather(., key = "depth", value = "winter_silicate", -lat, -lon) %>% 
  mutate(depth = as.numeric(depth)) %>% 
  arrange(lat, lon, depth) %>% 
  filter(between(lon, -47, -38),
         between(lat, 39,57)) %>% 
  drop_na() %>% 
  mutate(bin = ceiling(lat),
         winter_silicate = round(winter_silicate * 1.025,1)) %>% 
  left_join(., woa_mld.df %>% 
              group_by(bin) %>%  
              filter(mld == max(mld, na.rm = T)) %>% 
              select(bin, mld) %>% 
              distinct()) %>% 
  mutate(coord = paste(lat, lon, sep = ",")) %>% 
  select(lat, lon, coord, bin, mld, depth, winter_silicate)
```

```{r}
#split the dataframe into a list, by coordinates
woa.winter.si.clim.list <-  split(woa.winter.si.clim, woa.winter.si.clim$coord)
```


```{r, message = FALSE, warning = FALSE}
#apply function to list
added.mld.woa.winter.si.clim.list <- lapply(woa.winter.si.clim.list, woa_add_mld.func)
```

```{r}
#save the list as a data frame 
added.mld.woa.winter.si.clim.df <- plyr::ldply(added.mld.woa.winter.si.clim.list, data.frame) %>% 
  group_by(coord) %>% 
  distinct(., depth, .keep_all = T) %>% 
  select(-.id) %>% 
  ungroup() %>% 
  arrange(coord, depth)

```

```{r}
#again, split the dataframe into a list
to_interpolate.woa.winter.si.clim.list <- split(added.mld.woa.winter.si.clim.df, added.mld.woa.winter.si.clim.df$coord)
```

```{r}
#create a function that will linearly interpolate silicate according to the depth intervals 
woa_interpolate_si.func <- function(a) {
b <- a %>% 
  select(depth:ncol(.)) %>% 
  zoo(., order.by = .$depth) 
interp_si <- round(as.numeric(na.approx(b$winter_silicate, na.rm = F)),1)
c <- a %>% 
  mutate(winter_silicate = interp_si)
}

```

```{r}
#apply function to list 
woa.clim_interpolated_si.list <- lapply(to_interpolate.woa.winter.si.clim.list, woa_interpolate_si.func)
```

```{r}
#save the list as a data frame and calculate the mixed layer silicate concentration for each latitudinal bin
woa.clim_si_interp.df <- plyr::ldply(woa.clim_interpolated_si.list, data.frame) %>% 
  select(-.id) %>% 
  group_by(coord) %>% 
  filter(depth <= mld) %>% 
  mutate(coord_winter_si = round(mean(winter_silicate, na.rm = T),1)) %>%
  ungroup() %>% 
  select(lat,lon, bin, mld, coord_winter_si) %>% 
  distinct() %>%
  group_by(bin) %>%
  mutate(bin_winter_si = round(mean(coord_winter_si, na.rm = T),1),
         bin_winter_si_sd = round(sd(coord_winter_si, na.rm = T),1)) %>%
  add_tally() %>%
  select( bin, mld, bin_winter_si, bin_winter_si_sd, n) %>% 
  ungroup() %>% 
  distinct() 
```

```{r echo = FALSE, results = 'asis'}
kable(woa.clim_si_interp.df, caption = "WOA18 Climatology Winter Silicate Conditions. MLDs represent the maximum calculated MLD for the profiles within latitudinal bin. n refers to the total number of profiles for  each latitudinal bin (multiple because of the range in longitude)")
```

# Comparison of NAAMES and Public Datasets

We'll combine the dataset used in the manuscript with the tables generated above so that we can compare (1) MLDs, (2) mixed winter conditions and (3) NCP values. 

```{r message = FALSE}
merge.glodap <- glodap.winter.cond %>% 
  rename(g.winter_n = winter_n,
         g.winter_si = winter_si,
         g.winter_c = winter_tco2,
         g.mld = mld) %>%
  left_join(., ncp_spring %>% select(bin, ncp_spring)) %>% 
  left_join(., ncp_summer %>% select(bin, ncp_summer)) %>% 
  rename(g.ncp_spring = ncp_spring,
         g.ncp_summer = ncp_summer)
  
merge.woa_stat <- woa.winter.n %>% 
  select(bin, woa_n) %>% 
  rename(w.winter_n.surf = woa_n) %>% 
  full_join(., woa_si_interp.df %>% select(bin:winter_si)) %>% 
  rename(w.winter_si = winter_si, 
         w.mld = mld)

merge.woa_clim <- woa.clim_n_interp.df %>% 
  select(bin, mld, bin_winter_n) %>% 
  left_join(., woa.clim.spring %>% select(bin, ncp_spring)) %>% 
  left_join(., woa.clim.summer %>% select(bin, ncp_summer)) %>% 
  left_join(., woa.clim_si_interp.df %>% select(bin, bin_winter_si)) %>% 
  rename(wc.mld = mld, 
         wc.winter_n = bin_winter_n,
         wc.ncp_spring = ncp_spring,
         wc.ncp_summer = ncp_summer, 
         wc.winter_si = bin_winter_si)

combined.data <- export_summary %>% 
  rename(bin = degree_bin) %>% 
  left_join(., merge.woa_clim) %>% 
  left_join(., merge.woa_stat) %>% 
  left_join(., merge.glodap) %>% 
  ungroup()
  
```
## Regressions

### Mixed Layer Depths

```{r}
regression.data_mld <- combined.data %>% 
  select(Max_MLD, wc.mld, w.mld, g.mld) %>% 
  gather(., "product",  "value", -Max_MLD) %>% 
  mutate(per_diff = ((abs(Max_MLD - value))/Max_MLD)*100) %>% 
  distinct() %>% 
  drop_na()
```

```{r echo = FALSE}
regression.data_mld.sum <- summary(regression.data_mld)
pander(regression.data_mld.sum)
```


```{r message = FALSE}
regression.mld <- lmodel2(value ~ Max_MLD, data = regression.data_mld, nperm = 99) 
```

```{r echo = FALSE}
regression.mld
```

```{r fig.height = 8, fig.width = 12, fig.align = "center", warning = FALSE}
mld.plot <- regression.data_mld %>% 
  mutate(product = ifelse(product == "wc.mld", "WOA18_AN", product),
         product = ifelse(product == "w.mld", "WOA18_MN", product),
         product = ifelse(product == "g.mld", "Gv2_2019", product)) %>% 
  ggplot(aes(x = Max_MLD, y = value)) +
   geom_abline(intercept = regression.mld$regression.results[3,2],
              slope = regression.mld$regression.results[3,3],colour = "black", linetype = 2, size = 1) +
  geom_point(aes(fill = product),  color = "black", shape = 21, size = 8, alpha = 0.7, stroke = 2) +
  geom_abline(aes(intercept = 0, slope = 1)) +
  labs(y = expression(italic(paste("WOA18 or Gv2_2019 MLD, m"))), x = expression(italic(paste("NAAMES ARGO MLD, m"))), colour = "") +
  custom_theme() +
  scale_y_continuous(breaks = pretty_breaks()) +
  scale_x_continuous(breaks = pretty_breaks()) +
  scale_fill_manual(values = custom.colors)

mld.plot
```

### Winter Nitrate Condition

```{r}
regression.data_winter.n <- combined.data %>% 
  select(redis_N_vol, wc.winter_n, w.winter_n.surf, g.winter_n) %>% 
  gather(., "product",  "value", -redis_N_vol) %>% 
  mutate(per_diff = ((abs(redis_N_vol - value))/redis_N_vol)*100) %>% 
  distinct() %>% 
  drop_na()
```

```{r echo = FALSE}
regression.data_winter.n.sum <- summary(regression.data_winter.n)
pander(regression.data_winter.n.sum)
```


```{r message = FALSE}
regression.winter_n <- lmodel2(value ~ redis_N_vol, data = regression.data_winter.n, nperm = 99) 
```

```{r echo = FALSE}
regression.winter_n
```

```{r fig.height = 8, fig.width = 12, fig.align = "center", warning = FALSE}
winter.n.plot <- regression.data_winter.n %>% 
  mutate(product = ifelse(product == "wc.winter_n", "WOA18_AN", product),
         product = ifelse(product == "w.winter_n.surf", "WOA18_MN", product),
         product = ifelse(product == "g.winter_n", "Gv2_2019", product)) %>% 
  ggplot(aes(x = redis_N_vol, y = value)) +
   geom_abline(intercept = regression.winter_n$regression.results[3,2],
              slope = regression.winter_n$regression.results[3,3],colour = "black", linetype = 2, size = 1) +
  geom_point(aes(fill = product),  color = "black", shape = 21, size = 8, alpha = 0.7, stroke = 2) +
  geom_abline(aes(intercept = 0, slope = 1)) +
  labs(y = expression(italic(paste("WOA18 or Gv2_2019 NO"[3],", µmol N L"^"-1"))), x = expression(italic(paste("Reconstructed NO"[3],", µmol N L"^"-1"))), colour = "") +
  custom_theme() +
  scale_y_continuous(breaks = pretty_breaks()) +
  scale_x_continuous(breaks = pretty_breaks()) +
  scale_fill_manual(values = custom.colors) +
  ggtitle("Winter Nitrate Condition")

winter.n.plot
```

### Winter Silicate Condition

```{r}
regression.data_winter.si <-  combined.data %>% 
  select(redis_Si_vol, wc.winter_si, w.winter_si, g.winter_si) %>% 
  gather(., "product",  "value", -redis_Si_vol) %>% 
  mutate(per_diff = ((abs(redis_Si_vol - value))/redis_Si_vol)*100) %>% 
  distinct() %>% 
  drop_na()
```

```{r echo = FALSE}
regression.data_winter.si.sum <- summary(regression.data_winter.si)
pander(regression.data_winter.si.sum)
```


```{r message = FALSE}
regression.winter_si <- lmodel2(value ~ redis_Si_vol, data = regression.data_winter.si, nperm = 99) 
```

```{r echo = FALSE}
regression.winter_si
```

```{r fig.height = 8, fig.width = 12, fig.align = "center", warning = FALSE}
winter.si.plot <- regression.data_winter.si %>% 
  mutate(product = ifelse(product == "wc.winter_si", "WOA18_AN", product),
         product = ifelse(product == "w.winter_si", "WOA18_MN", product),
         product = ifelse(product == "g.winter_si", "Gv2_2019", product)) %>% 
  ggplot(aes(x = redis_Si_vol, y = value)) +
   geom_abline(intercept = regression.winter_si$regression.results[3,2],
              slope = regression.winter_si$regression.results[3,3],colour = "black", linetype = 2, size = 1) +
  geom_point(aes(fill = product),  color = "black", shape = 21, size = 8, alpha = 0.7, stroke = 2) +
  geom_abline(aes(intercept = 0, slope = 1)) +
  labs(y = expression(italic(paste("WOA18 or Gv2_2019 SiO"[4],", µmol Si L"^"-1"))), x = expression(italic(paste("Reconstructed SiO"[4],", µmol Si L"^"-1"))), colour = "") +
  custom_theme() +
  scale_y_continuous(breaks = pretty_breaks(), limits = c(0,10)) +
  scale_x_continuous(breaks = pretty_breaks(), limits = c(0,10)) +
  scale_fill_manual(values = custom.colors) +
  ggtitle("Winter Silicate Condition")

winter.si.plot
```


### Spring NCP

```{r}
regression.data_ncp.spring <-  combined.data %>%
  filter(Season == "Late Spring") %>%
  select(NCP_mol_100, wc.ncp_spring) %>% 
  gather(., "product",  "value", -NCP_mol_100) %>% 
  mutate(per_diff = ((abs(NCP_mol_100 - value))/NCP_mol_100)*100) %>% 
  distinct() %>% 
  drop_na()
```

```{r echo = FALSE}
regression.data_ncp.spring.sum <- summary(regression.data_ncp.spring)
pander(regression.data_ncp.spring.sum)
```


```{r message = FALSE}
regression.ncp.spring <- lmodel2(value ~ NCP_mol_100, data = regression.data_ncp.spring, nperm = 99) 
```

```{r echo = FALSE}
regression.ncp.spring
```

```{r fig.height = 8, fig.width = 12, fig.align = "center", warning = FALSE}
ncp.spring.plot <- regression.data_ncp.spring %>% 
  mutate(product = ifelse(product == "wc.ncp_spring", "WOA18_AN", product),
         product = ifelse(product == "w.ncp_spring", "WOA18_MN", product),
         product = ifelse(product == "g.ncp_spring", "Gv2_2019", product)) %>% 
  ggplot(aes(x = NCP_mol_100, y = value)) +
   geom_abline(intercept = regression.ncp.spring$regression.results[3,2],
              slope = regression.ncp.spring$regression.results[3,3],colour = "black", linetype = 2, size = 1) +
  geom_point(aes(fill = product),  color = "black", shape = 21, size = 8, alpha = 0.7, stroke = 2) +
  geom_abline(aes(intercept = 0, slope = 1)) +
  labs(y = expression(italic(paste("WOA18 or Gv2_2019 NCP, µmol C"," ", "L"^"-1"))), x = expression(italic(paste("NAAMES NCP, µmol C"," ", "L"^"-1"))), colour = "") +
  custom_theme() +
  scale_y_continuous(breaks = pretty_breaks(), limits = c(-1, 6)) +
  scale_x_continuous(breaks = pretty_breaks(), limits = c(-1, 6)) +
  scale_fill_manual(values = custom.colors) +
  ggtitle("Spring NCP")

ncp.spring.plot
```


### Summer NCP

```{r}
regression.data_ncp.autumn <-  combined.data %>%
  filter(Season == "Early Autumn") %>% 
  select(NCP_mol_100, wc.ncp_summer,  g.ncp_summer) %>% 
  gather(., "product",  "value", -NCP_mol_100) %>% 
  mutate(per_diff = ((abs(NCP_mol_100 - value))/NCP_mol_100)*100) %>% 
  distinct() %>% 
  drop_na()
```

```{r echo = FALSE}
regression.data_ncp.autumn.sum <- summary(regression.data_ncp.autumn)
pander(regression.data_ncp.autumn.sum)
```


```{r message = FALSE}
regression.ncp.autumn <- lmodel2(value ~ NCP_mol_100, data = regression.data_ncp.autumn, nperm = 99) 
```

```{r echo = FALSE}
regression.ncp.autumn
```

```{r fig.height = 8, fig.width = 12, fig.align = "center", warning = FALSE}
ncp.autumn.plot <- regression.data_ncp.autumn %>% 
  mutate(product = ifelse(product == "wc.ncp_summer", "WOA18_AN", product),
         product = ifelse(product == "w.ncp_summer", "WOA18_MN", product),
         product = ifelse(product == "g.ncp_summer", "Gv2_2019", product)) %>% 
  ggplot(aes(x = NCP_mol_100, y = value)) +
   geom_abline(intercept = regression.ncp.autumn$regression.results[3,2],
              slope = regression.ncp.autumn$regression.results[3,3],colour = "black", linetype = 2, size = 1) +
  geom_point(aes(fill = product),  color = "black", shape = 21, size = 8, alpha = 0.7, stroke = 2) +
  geom_abline(aes(intercept = 0, slope = 1)) +
  labs(y = expression(italic(paste("WOA18 or Gv2_2019 NCP, µmol C"," ", "L"^"-1"))), x = expression(italic(paste("NAAMES NCP, µmol C"," ", "L"^"-1"))), colour = "") +
  custom_theme() +
  scale_y_continuous(breaks = pretty_breaks(), limits = c(0, 10)) +
  scale_x_continuous(breaks = pretty_breaks(), limits = c(0, 10)) +
  scale_fill_manual(values = custom.colors) +
  ggtitle("Autumn NCP")

ncp.autumn.plot
```

# ARGO Mixed Layers

Here we explore the mixed layer climatology and database provided by Holte et al., 2017, which are available [online](http://mixedlayer.ucsd.edu)

We are interested in both the magnitude and standard deviation (interannual variability) of the maximum mixed layer for the NAAMES region. 

The source data are avaiable as MATLAB or NetCDF files. We will work with the NetCDF file.

```{r}
ncin <- nc_open("~/Google Drive File Stream/Shared drives/NAAMES_Carlson/DATA/FINAL/MANUSCRIPT_DATA/Export_MS/Input/Clim_Argo/Argo_mixedlayers_monthlyclim_05092018.nc")
```

## Data Wrangling

```{r}
#get longitude and latitude
lon <- ncvar_get(ncin,"lon")
nlon <- dim(lon)

lat <- ncvar_get(ncin,"lat")
nlat <- dim(lat)

#get time
mon <- ncvar_get(ncin,"month")

tunits <- ncatt_get(ncin,"month","units")
nt <- dim(mon)

#get maximum mld, density algorithm
mld_array <- ncvar_get(ncin, "mld_da_max")
mld_name <- ncatt_get(ncin,"mld_da_max","long_name")
mld_units <- ncatt_get(ncin,"mld_da_max","units")
fillvalue <- ncatt_get(ncin,"mld_da_max","_FillValue")

#get sd_mld
sd_array <- ncvar_get(ncin, "mld_da_std")

#close net cdf file
nc_close(ncin)

#replace fill values of arrays (-9999) with NA
mld_array[mld_array == fillvalue$value] <- NA
sd_array[sd_array == fillvalue$value] <- NA
```

## Plot Winter Data

```{r}
# get a single slice or layer (January)
m <- 1
mld_slice <- mld_array[m,,]

grid <- expand.grid(lon = lon, lat = lat)
cutpts <- c(0, 80,  100,  120,  140, 160, 200, 300, 400, 500)
levelplot(mld_slice ~ lon * lat, data = grid, at = cutpts, cuts = 10, pretty = T, 
          col.regions = (rev(brewer.pal(10,"RdBu"))), 
          xlim = c(-80, 0), ylim = c(0, 80),
          main = "January",
          xlab = "Longitude, ˚W",
          ylab = "Latitude, ˚N")
```

```{r echo = FALSE}
# get a single slice or layer 
m <- 2
mld_slice <- mld_array[m,,]

grid <- expand.grid(lon = lon, lat = lat)
cutpts <- c(0, 80,  100,  120,  140, 160, 200, 300, 400, 500)
levelplot(mld_slice ~ lon * lat, data = grid, at = cutpts, cuts = 10, pretty = T, 
          col.regions = (rev(brewer.pal(10,"RdBu"))), 
          xlim = c(-80, 0), ylim = c(0, 80),
          main = "February",
          xlab = "Longitude, ˚W",
          ylab = "Latitude, ˚N")
```

```{r echo = FALSE}
# get a single slice or layer 
m <- 3
mld_slice <- mld_array[m,,]

grid <- expand.grid(lon = lon, lat = lat)
cutpts <- c(0, 80,  100,  120,  140, 160, 200, 300, 400, 500)
levelplot(mld_slice ~ lon * lat, data = grid, at = cutpts, cuts = 10, pretty = T, 
          col.regions = (rev(brewer.pal(10,"RdBu"))), 
          xlim = c(-80, 0), ylim = c(0, 80),
          main = "March",
          xlab = "Longitude, ˚W",
          ylab = "Latitude, ˚N")
```

## Dataframe

```{r}
#Create dataframe of max mld data 
# reshape the array into vector
mld_vec_long <- as.vector(mld_array)

# reshape the vector into a matrix
mld_mat <- matrix(mld_vec_long, nrow = nlon*nlat, ncol = nt)

# create a dataframe
lonlat <- as.matrix(expand.grid(lon,lat))
mld_df <- data.frame(cbind(lonlat,mld_mat))
names(mld_df) <- c("lon","lat","mld_Jan","mld_Feb","mld_Mar","mld_Apr","mld_May","mld_Jun",
                   "mld_Jul","mld_Aug","mld_Sep","mld_Oct","mld_Nov","mld_Dec")

#Create dataframe of stdevs of max mld data
# reshape the array into vector
sd_vec_long <- as.vector(sd_array)

# reshape the vector into a matrix
sd_mat <- matrix(sd_vec_long, nrow = nlon*nlat, ncol = nt)
# create a dataframe
sd_df <- data.frame(cbind(lonlat,sd_mat))
names(sd_df) <- c("lon","lat","sd_Jan","sd_Feb","sd_Mar","sd_Apr","sd_May","sd_Jun",
                  "sd_Jul","sd_Aug","sd_Sep","sd_Oct","sd_Nov","sd_Dec")

#Combine the dataframes ====
clim_argo <- mld_df %>% 
  left_join(., sd_df)

region_clim_argo <- clim_argo %>% 
  filter(between(lon, -47, -38),
         between(lat, 39,57)) 
```

## Interannual Winter Variability

```{r}
intvar <- region_clim_argo %>% 
  select(lat, lon, mld_Nov, mld_Dec, mld_Jan, mld_Feb, mld_Mar, mld_Apr, sd_Nov, sd_Dec, sd_Jan, sd_Feb, sd_Mar, sd_Apr) %>% 
  mutate_at(vars(mld_Nov:sd_Apr), round)

```

```{r echo = FALSE}
intvar.sum <- summary(intvar)
pander(intvar.sum)
```

```{r}
mld.sum <- naames_mld  %>% 
  summary(.)
pander(mld.sum)
```



```{r warning = FALSE, message = FALSE, fig.height = 10, fig.width = 12, fig.align = "center", warning = FALSE}
naames_max_mlds <- naames_mld %>% 
  select(degree_bin, mean_mld) %>% 
  group_by(degree_bin) %>% 
  mutate(max_mld = max(mean_mld)) %>% 
  select(-mean_mld) %>% 
  distinct()

intvar.plot.data <- intvar %>%
  rename(Nov = mld_Nov,
         "Nov sd" = sd_Nov,
         Dec = mld_Dec,
         "Dec sd" = sd_Dec,
         Jan = mld_Jan,
         "Jan sd" = sd_Jan,
         Feb = mld_Feb,
         "Feb sd" = sd_Feb,
         Mar = mld_Mar,
         "Mar sd" = sd_Mar,
         Apr = mld_Apr,
         "Apr sd" = sd_Apr,
         ) %>% 
  select(-Jan, -"Jan sd", -Dec, -"Dec sd", -lon) %>% 
  mutate(bin = ceiling(lat)) %>% 
  select(lat, bin, everything()) %>% 
  left_join(., naames_max_mlds %>% 
              rename(bin = degree_bin,
                     "Cruise" = max_mld)) %>% 
     left_join(., argo_mld %>% 
              rename(bin = degree_bin,
                     "ARGO" = Max_MLD)) %>%
  gather(., key = "param", value = "z", -lat,  -bin) %>% 
  mutate(type = ifelse(param == "ARGO", "ARGO", NA),
         type = ifelse(param == "Cruise", "Cruise", type),
         type = ifelse(is.na(type), "Climatology", type),
         )
intvar.plot.data$param <- factor(intvar.plot.data$param, levels = levels)

intvar.plot <- intvar.plot.data %>% 
  ggplot(aes(x = param, y = z)) +
  geom_boxplot(aes(fill = type)) +
  scale_fill_brewer(palette = "Set1") +
  scale_fill_manual(values = custom.colors) +
  guides(fill = FALSE) +
  custom_theme() +
  labs(x = "", y = expression(italic("Maximum Mixed Layer, m")))

intvar.plot
```





















































































